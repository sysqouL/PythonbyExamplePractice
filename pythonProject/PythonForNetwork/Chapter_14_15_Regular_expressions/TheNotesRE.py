#-------------------------------------------------
"""
"""

"""
    В Python для работы с регулярными выражениями используется модуль re. Соответственно,
    для начала работы с регулярными выражениями надо его импортировать.
        import re
        
    В Python некоторые символы строки надо экранировать, чтобы они воспринимались правиль-
    но. К таким символам относится, например, \. Чтобы написать правильно строку, в которой
    находятся два символа \\, можно использовать raw-строку и тогда каждый символ будет вос-
    приниматься как написано. Raw-строки отличаются от обычных тем, что при создании строки,
    в начале пишется буква r:
        r"\\data"
        
    У функции search два обязательных параметра:
        • regex - регулярное выражение
        • string - строка, в которой ищется совпадение
    Синтаксис функции search:
        match = re.search(regex, string)
    
    Если совпадение было найдено, функция вернет специальный объект Match. Если же совпа-
    дения не было, функция вернет None.
    При этом особенность функции search в том, что она ищет только первое совпадение.
    
    Пример:
        import re
        int_line = ' MTU 1500 bytes, BW 10000 Kbit, DLY 1000 usec,'
        match = re.search(r'MTU', int_line)
    
    У объекта match есть несколько методов, которые позволяют получать разную информацию
    о полученном совпадении. Например, метод group показывает, что в строке совпало с опи-
    санным выражением.
    
    
    Полностью возможности регулярных выражений проявляются при использовании специаль-
    ных символов. Например, символ \d означает цифру, а + означает повторение предыдущего
    символа один или более раз. Если их совместить \d+, получится выражение, которое означает
    одну или более цифр. Пример:
    
        int_line = ' MTU 1500 bytes, BW 10000 Kbit, DLY 1000 usec,'
        match = re.search(r'BW \d+', int_line)
        match.group() =
        'BW 10000'
    
    Пример 2:
        log2 = 'Oct 3 12:49:15.941: %SW_MATM-4-MACFLAP_NOTIF: Host f04d.a206.7fd6 
        in vlan 1 is flapping between port Gi0/5 and port Gi0/16'
        re.search(r'Host (\S+) in vlan (\d+) is flapping between port (\S+) and port (\S+)', log2).groups() = 
        ('f04d.a206.7fd6', '1', 'Gi0/5', 'Gi0/16')
    
    Метод groups возвращает только те части исходной строки, которые попали в круглые скоб-
    ки. Таким образом, заключив часть выражения в скобки, можно указать, какие части строки
    надо запомнить. \S+ описывает все символы, кроме whitespace (пробел, таб и другие)
"""


#-----------------------------------------------------------------------------------------------------------


"""
    Наборы символов
    В Python есть специальные обозначения для наборов символов:
        • \d - любая цифра
        • \D - любое нечисловое значение
        • \s - пробельные символы
        • \S - все, кроме пробельных символов
        • \w - любая буква, цифра или нижнее подчеркивание
        • \W - все, кроме букв, цифр или нижнего подчеркивания
    
    Символы повторения
        • regex+ - одно или более повторений предшествующего элемента
        • regex* - ноль или более повторений предшествующего элемента
        • regex? - ноль или одно повторение предшествующего элемента
        • regex{n} - ровно n повторений предшествующего элемента
        • regex{n,m} - от n до m повторений предшествующего элемента
        • regex{n,} - n или более повторений предшествующего элемента
    
    Пример:
    IP-адрес можно описать выражением \d+\.\d+\.\d+\.\d+. Тут плюс используется, чтобы ука-
    зать, что цифр может быть несколько. А также встречается выражение \.. что бы экранировать точку
    
        sh_ip_int_br = 'Ethernet0/1 192.168.200.1 YES NVRAM up up'
        re.search(r'\d+\.\d+\.\d+\.\d+', sh_ip_int_br).group() = 
        '192.168.200.1'
    
    Пример 2:
        line = '1500 aab1.a1a1.a5d3 FastEthernet0/1'
        re.search(r'\d+\s+\S+', line).group() =
        '1500 aab1.a1a1.a5d3'
    
    Пример 3:
        email1 = 'user1@gmail.com'
        email2 = 'user2.test@gmail.com'
        re.search(r'\w+\.*\w+@\w+\.\w+', email1).group() =
        'user1@gmail.com'
        re.search(r'\w+\.*\w+@\w+\.\w+', email2).group() = 
        'user2.test@gmail.com'

    Специальные символы
        • . - любой символ, кроме символа новой строки
        • ^ - начало строки
        • $ - конец строки
        • [abc] - любой символ в скобках
        • [^abc] - любой символ, кроме тех, что в скобках
        • a|b - элемент a или b
        • (regex) - выражение рассматривается как один элемент. Кроме того, подстрока, кото-
        рая совпала с выражением, запоминается
    
    По умолчанию символы повторения в регулярных выражениях жадные (greedy). Это значит,
    что результирующая подстрока, которая соответствует шаблону, будет наиболее длинной.
    Если нужно отключить жадность, достаточно добавить знак вопроса после символов повто-
    рения.
"""


# ----------------------------------------------------------------------------------------------------------


"""
    Группировка выражений
    Группировка выражений указывает, что последовательность символов надо рассматривать
    как одно целое. Однако это не единственное преимущество группировки.
    Кроме этого, с помощью групп можно получать только определенную часть строки, которая
    была описана выражением. Это очень полезно в ситуациях, когда надо описать строку до-
    статочно подробно, чтобы отобрать нужные строки, но в то же время из самой строки надо
    получить только определенное значение.

    В Python есть два варианта использования групп:
        • Нумерованные группы
        • Именованные группы
        
    Пример нумерованной группы:
    line = "FastEthernet0/1 10.0.12.1 YES manual up up"
    match = re.search(r'(\S+)\s+([\w.]+)\s+.*', line)
    В данном примере указаны две группы:
        • первая группа - любые символы, кроме пробельных
        • вторая группа - любая буква или цифра (символ \w) или точка
    Теперь можно обращаться к группам по номеру.
        match.group(1) =
        'FastEthernet0/1'
        match.group(2) =
        '10.0.12.1'
    
    или
        match.group(1, 2)
        ('FastEthernet0/1', '10.0.12.1')
    
    
    Синтаксис именованной группы (?P<name>regex):
        line = "FastEthernet0/1 10.0.12.1 YES manual up up"
        match = re.search(r'(?P<intf>\S+)\s+(?P<address>[\d.]+)\s+', line)
    Теперь к этим группам можно обращаться по имени:
        match.group('intf')
        'FastEthernet0/1'
        match.group('address')
        '10.0.12.1'
    
    Также очень полезно то, что с помощью метода groupdict(), можно получить словарь, где
    ключи - имена групп, а значения - подстроки, которые им соответствуют:
        match.groupdict()
        {'address': '10.0.12.1', 'intf': 'FastEthernet0/1'}
"""