----------------------------------------------------------------------------------------------------------------------
    TextFSM - это библиотека для обработки вывода с сетевых устройств. Позволяет создавать шаблоны, по которым
    будет обрабатываться вывод команды.

    Установка:
        pip install textfsm

    Для исп TextFSM надо создать шаблон, по которому будет обрабатываться вывод команды. Пример

        R2# traceroute 90.0.0.9 source 33.0.0.2
        traceroute 90.0.0.9 source 33.0.0.2
        Type escape sequence to abort
        Tracing route to 90.0.0.9
        VRF info: (vrf in name/id, vrf out name/id)
            1 ip 1 msec 0 msec 0 msec
            2 ip time time time
            3 ip time time time
            4 ip time time time
        Если нужно получить hop'ы то шаблон TextFSM:
        Value ID (\d+)                      - одна или более цифр(номера hop'оф)
        Value Hop (\d+(\.\d+){3})           - ip адрес
        Start
             ${ID} ${Hop} -> Record         - сам шаблон TextFSM

        В Python:
            import textfsm
            traceroute = " данные "
            with open('шаблон') as template:
                fsm = textfsm.TextFSM(template)         - класс, обрабатывающий шаблон и создающий объект в TextFSM
                result = fsm.ParseText(template)        - метод, обрабатывающий вывод и возвращающий список списков

            print(fsm.header)                           - содержит имена переменных и результат обработки
            print(result)
        Строки совпавшие с шаблоном возвращаются в виде списка списков

----------------------------------------------------------------------------------------------------------------------

    Любой шаблон TextFSM состоит из:
        - определение переменных
        - определение состоянии
    На вышеописанном примере переменные это Value ID и Hop, а сексия определения состоянии начинается со Start
    В секции определения переменных не должно быть пустых строк - пустая строка означает завершение секции
    Value - ключевое слово
    После Value и перед Именем можно указывать опции:
        - Filldown - значение, которое ранее совпало с регульряным выражением, запоминается, до следующей обработки
        строки (если не было явно очищенно или снова совпало регулярное выражение)
         - key - определяет, что поле содержит уникальный идентификатор строки
         - Required - строка, которая обрабатывается, будет записана только в тои случае, если эта переменная отсутствует
         - List - значение это список, и каждое совпадение с регулярным выражением будет добавлять в список элемент. По
          умолчанию каждое следующее совпадение перезаписывает предидущее
          - Fillup - работает как Filldown, но заполняет пустые значение выше до тех пор пока не найдет совпадение.
          Не совместимо с Required
    Блок состояний:
        - каждое состояние должно быть отделено пустой строкой
        - первая строка - имя состояния
        - затем идут описания правил, начин с 1-2 пробелов или ^
        - нач состояние всегда Start
    Зарезервированные состояния: Start, End , EOF

    Правила состояний:
        - TextFSM обрабатывает входящие строки и сравнивает их с правилами
        - если правило (рег выражение) совпадает со строкой, выполняются действия, описанные в правиле, и для след
        строки процесс повторяется заного
    Формат правил: ^regex [-> action]

----------------------------------------------------------------------------------------------------------------------

    Действия в правилах
    После регулярного выражения в правиле могут указываться действия:
    • между регулярным выражением и действием должен быть символ ->
    • действия могут состоять из трех частей в таком формате: L.R S
    – L - Line Action - действия, которые применяются к входящей строке
    – R - Record Action - действия, которые применяются к собранным значениям
    – S - State Transition - переход в другое состояние
    • по умолчанию используется Next.NoRecord

    Line Actions:
    • Next - обработать строку, прочитать следующую и начать проверять её с начала состо-
    яния. Это действие используется по умолчанию, если не указано другое

    Record Action
    Record Action - опциональное действие, которое может быть указано после Line Action. Они
    должны быть разделены точкой. Типы действий:
    • NoRecord - не выполнять ничего. Это действие по умолчанию, когда другое не указано
    • Record - запомнить значения, которые совпали с правилом. Все переменные, кроме тех,
    где указана опция Filldown, обнуляются.
    • Clear - обнулить все переменные, кроме тех, где указана опция Filldown.
    • Clearall - обнулить все переменные.
    Разделять действия точкой нужно только в том случае, если нужно указать и Line, и Record
    действия. Если нужно указать только одно из них, точку ставить не нужно.

    State Transition
    После действия может быть указано новое состояние:
    • состояние должно быть одним из зарезервированных или определенных в шаблоне
    • если входная строка совпала:
    – все действия выполняются,
    – считывается следующая строка,
    – затем текущее состояние меняется на новое, и обработка продолжается в новом
    состоянии.
    Если в правиле используется действие Continue, то в нём нельзя использовать переход в
    другое состояние. Это правило нужно для того, чтобы в последовательности состояний не
    было петель.

    Error Action
    Специальное действие Error останавливает всю обработку строк, отбрасывает все строки,
    которые были собраны до сих пор, и возвращает исключение.
    Синтаксис этого действия такой:
    ^regex -> Error [word|"string"]